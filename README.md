# JSP



## JSP(Java Server Page)
- HTML을 중심으로 자바와 같이 연동하여 사용하는 웹 언어이다. 
- HTML에서 JAVA를 사용  --> 서블릿보다 간단, 서블릿의 장점 극복
- HTML코드 안에 JAVA코드를 작성할 수 있는 언어이다.    -> 하나의 파일에 두 개 이상의 언어가 섞이면 분업, 가독성이 떨어진다 따라서 현재는 지양하는 작업방식이다.

	
### JSP 생명주기
	init	-초기화 
	do	- 작동, service()메소드
	destroy	- 파괴,종료

### 서버(server)
사용자의 요청에 맞는 서비스를 제공해주는 것
```	
	- 요청(request)	: 클라이언트 ---> 서버
	- 응답(response)	: 서버 ---> 클라이언트
```

### 웹(Web)
	페이지 요청과 응답이 일어나는 장소 

### 웹 서버(http) - 아파치
	사용자의 요청이 정적 데이터인지 동적 데이터인지 판단한다.
	정적 데이터일 경우 이미 준비된 HTML 문서를 그대로 응답해주며,
	동적 데이터라면 웹 컨데이너에 요청을 보낸다.

### 웹 컨테이너(서블릿 컨테이너)
*웹컨테이너(서블릿 컨테이너) -> 서블릿은 여러 개 존재(대기)한다 -> 자바는 멀티스레드이다, 하나 당 하나의 스레드가 생기므로, 서블릿도 여러 개 생성된다.*
- 동적 데이터일 경우 JSP, 서블릿으로 연산 및 제어 그리고 DB까지 접근한다.
- DB에 접근하는 연산을 복잡한 연산이라고 하며, JAVA로 처리한다.
- 동적 데이터가 정제된 데이터(정적 데이터)로 완성되면 이를 웹 서버로 응답해준다.


### web.xml
web.xml - 표지판, 이정표 역할
- 요청에 따라 경로를 지시하는 설정파일.
- 프로젝트 하나 당 하나 설정|각 프로젝트마다 설정이 충돌하는것을 막기 위해
- 서버를 연동하면, 공용으로 사용할 수 있는 web.xml파일이 생성이 된다,   
--> 이것은 공통적인 사항이기 때문에, 각 프로젝트의 설정과 겹쳐버리게 된다.(각각의 사항이 전체에 관여)   
이러한 충돌을 막기 위해서 각 프로젝트마다 설정파일이 생성된다.
- 만들 때 바로 체크하도록하고, 못할경우 JavaEE Tools에서 설정한다.

### WAS(Web Application Server) - 톰캣
- 동적 데이터를 처리할 서블릿을 메모리에 할당하며, web.xml을 참조한 두 알맞는 서블릿에 대한
- Thread를 생성한다. 서블릿 요청과 서블릿 응답 객체 생성 후 서블릿에 전달하면,
- 연산 종료 후 메모리에서 해제시킨다.   
--> 요청 객체로 받아서 응답 객체로 전달한다   
--> 응답 객체로 어떤 곳으로 이동할지도 전달할 수 있다.

### 서블릿(Servlet)
- Java 코드 안에 HTML 코드를 작성할 수 있는 Java 프로그램이다.
- Thread에 의해 서블릿에 있는 service() 메소드가 호출된다.
- 전송 방식 요청에 맞게 doGet() 또는 doPost() 등의 메소드를 호출한다.
- 추상적, 자바 프로그램
- 구체화, 자바 프로그램 안에서 HTML을 사용할 수 있는 파일
- HTTP 서블릿 클래스를 상속하는 순간, JSP파일이 된다.   
--> 따옴표나 오타에 있어서 불편함이 있다.

__WebContent -> 웹표준파일 작성__

### 웹표준(W3C) - html, css, js	 ...
- 한 회사에서의 독점을 막기 위해 정한 표준
```
※패키지명 = 도메인,(com.koreait.app)-> .은 하위 연산자이므로, 파일 3개가 만들어진다.
Mapping - 검색
web.xml - 요청 시, 무조건 거침
설정한 주소를 만나면 동적데이터 이므로, 설정된 주소를 따라 이동하여 데이터를 정제한다.
```


## GET 방식과 POST 방식

### GET
- 주소에 데이터를 추가하여 전달하는 방식.
- 보통 쿼리 문자열(query string)에 포함되어 전송되므로, 길이에 제한이 있으며
- 주소에 데이터가 보이므로 보안상 취약점이 존재한다.
- 중요한 데이터 혹은 길이가 긴 데이터는 POST 방식을 사용하여 요청하는 것이 좋지만
- GET 방식이 POST 방식보다 상대적으로 빠른 전송방식이다.

### POST
- 데이터를 별도로 첨부(Header에 첨부)하여 전달하는 방식.
- 브라우저 히스토리에도 남지 않고 데이터는 쿼리 문자열과는 별도로 전송된다.
- 따라서 데이터의 길이에 제한도 없으며, GET 방식 보다 보안성이 높다.
- 하지만 GET 방식 보다 상대적으로 느리다.

## Ajax(Asynchronous Javascript and XML)
![ajax](https://user-images.githubusercontent.com/109493547/210162767-2b574973-2d9e-488f-8008-b12d4b6aadbf.png)
- 빠르게 동작하는 동적인 웹 페이지를 만들기 위한 개발 기법이다.
- Ajax는 웹 페이지 전체를 다시 로딩하지 않고도, 웹 페이지 일부분만을 갱신할 수 있고
- 백그라운드 영역에서 서버와 통신하여, 그 결과를 웹 페이지 일부분에만 표시할 수 있다.

### Ajax의 원리
![ajax원리](https://user-images.githubusercontent.com/109493547/210162972-364caa0d-d30d-4f11-b9e8-244e86ac757d.png)


### Ajax의 장점
1. 웹 페이지 전체를 다시 로딩하지 않고도, 웹 페이지 일부부만을 갱신할 수 있다.
2. 웹 페이지가 로드된 후에 서버로 데이터 요청을 보내거나 받을 수 있다.
3. 다양한 UI(동적 페이지)구현이 가능해진다.

### Ajax의 단점
1. 페이지 이동이 없기 때문에 히스토리 관리가 안된다.
2. 반복적인 데이터를 요청하면 느려지거나 작동하지 않게 된다.

* * *

### DBCP(DataBase Connection Pool)
- 사용자 요청이 있을 때 마다 DB연결을 한다면 코드가 복잡해지며,
- 많은 요청이 있을 때 연결 속도가 저하될 수 있다.
- 따라서 미리 Connection을 만들어 두고, 필요 시 저장된 공간에서
- 가져다 쓴 후 반환하는 기법이다.

### JNDI(Java Naming and Directory Interface)
- 디렉터리 서비스에서 제공하는 데이터 및 객체를 발견하고 참고하기 위한 자바 API이며,   
외부에 있는 객체를 가져오기 위한 기술이다.

## MyBatis Framework

![myBatis](https://user-images.githubusercontent.com/109493547/210162941-3a08f317-871a-4b59-ac3a-021b0a196303.png)

	소스코드 안에 SQL문을 작성하면 코드가 길어지고 섞여 있어서 유지보수 및 분업이 쉽지 않다.
	MyBatis는 기존 JDBC 방식과는 달리 SQL문을 XML파일에 작성함으로써 코드가 줄어들고,
	SQL문 수정이 편해진다. 또한 DBCP를 사용하여 커넥션을 여러 개 생성하기 때문에 JDBC만
	사용하는 것보다는 작업효율과 가독성이 좋아진다.
```
1. 테이블 생성
2. mapper.xml 생성
3. config.xml에 mapper.xml 경로 등록
4. DAO에서 mapper.xml에 작성한 쿼리 실행
```

* * *
## EL문과 JSTL
- 페이지 가독성 상승
- 자바 구문을 라이브러리 형태로 만들어 놓고 필요할 때 마다 태그로 꺼내쓰는 기술이다.
- JSP 페이지 내에서 자바코드와 HTML코드가 섞여 있으면 가독성이 떨어지고 복잡해진다.
- EL문과 JSTL문을 사용하면 HTML 태그로만 구성된 일관된 소스코드를 볼 수 있다는 장점이 있다.

### EL(Expression Language)
- 값을 간결하고 간편하게 출력할 수 있도록 해주는 기술 --> library
```
	자바			EL
	<%=name%>		${name}
	<%=member.getName()%>	${member.getName()}

	값을 찾을 때에는 작은 Scope에서 큰 Scope로 찾는다.
	page > request > session > application
	
	원하는 Scope의 변수를 찾을 때 아래와 같이 사용한다
	${param.name}	:전달받은 데이터 중 쿼리스트링으로 작성된 데이터에서 name을 찾는다
	${requestScope.name} : request 객체에 담긴 데이터 중 name을 찾는다.
	${sessionScope.name} : session 객체에 담긴 데이터 중 name을 찾는다.
```

### EL 연산자
```
	%, mod
	&&, and
	||, or
	>, lt
	<, gt
	>=, le
	<=, ge
	==, eq
	!=, ne
	empty : 값이 비어있으면 true, 값이 있으면 false
	!, not
```

### JSTL(JspStandard Tag Library)
- 연산자나 조건문, 반복문 등을 편하게 처리할 수 있으며, JSP페이지 내에서 자바코드를 사용하지 안혹   
로직을 구현할 수 있도록 효율적인 방법을 제공한다.
```
	자바				JSTL
		
	<% for(자료형 변수명: 반복자){} %>	<c:forEach var="" items="${반복자}"></c:forEach>
	<% for(초기식;조건식;증감식){}%>	<c:forEach var=""begin=""end=""></c:forEach>
					-c=카테고리, core-반드시 필요한것들
					-fn=카테고리, function - 어떤 기능들
```
### core 태그
```
core 태그의 종류 <c:></c:>
	<c:set>	: 변수선언
	<c:out>	: 변수 출력(사용)
	<c:if>	: if문
	<c:choose> : switch문(else if)
	<c:when> : case문
	<c:otherwise> : default(else)
	<c:forEach> : for문
```

* * *
## 소프트웨어 디자인 패턴

### [jsp 방식]
```
	a.jsp --> b.jsp --> c.jsp
```
- 각 페이지마다 필요 시 자바 코드가 작성되며, DB와 연결하는 코드도 jsp파일 안에서 모두 작성된다. 
- 분리되어 있지 않기 때문에 규모가 작은 프로젝트에 어울리는 방식이며,
- 코드가 확장될 수록 가독성이 떨어지고 분업과 유지보수가 좋지 않다.

## MVC
### [model1 방식]
```
	a.jsp --> b.jsp --> c.jsp
		↓
		DAO.java
```
- b.jsp에서 dao를 호출함으로써 자바코드가 섞이게 된다. 선언은 JAVA 페이지에 구현이 되어 있기 때문에
- jsp 내의 JAVA 코드 양이 줄어들지만 결국 사용은 .jsp 페이지에서 하기 때문에
- Controller(DAO 메소드를 사용하고 어디 페이지로 이동할 지)와 View가 섞이게 된다.
- 페이지가 확장될 수록 유지보수가 좋지 않다. 하지만 설계는 쉽다.

### [model2 방식]
```
   a.jsp   -->   web.xml   -->   Front-Controller.java   ------------>   c.jsp
                  ↓
               Controller.java
                   ↓
               DAO.java
                ↓
               DB
```
- a.jsp에서 다음 페이지를 이동하기 전 필요한 비지니스 로직을 완벽하게 분리하여 관리한다.
- 사용자가 정의한 확장자(.me, .bo, ...)를 페이지 이동 주소(URL)에 작성하게 되면
web.xml에 가서 경로를 찾는다. 
- web.xml에 파일 경로를 하나씩 모두 만들게 되면
코드가 길어지기 때문에 *.me와 같이 그룹화시킨 확장자로 요청을 하나의 경로로 보내주도록
설정해 놓는다.
- 이 경로를 알맞는 Front-Controller.java 경로로 설정해 놓는다.
- Front-Controller에서는 들어온 요청에서 .me앞의 요청 명으로 어떤 로직을 수행할 지를
판단하도록 분기처리를 한다.
- 비지니스 로직을 Front-Controller에서 작업하게 되면 마찬가지로 코드가 길어지고
유지보수 및 재사용이 어렵기 때문에 요청별 Controller를 만들어서 req와 resp를 받을
메소드를 선언하여 구현한다. 
- 따라서 Controller안에 선언된 메소드는 모든 Controller에
구현해야 하기 때문에 인터페이스를 선언하여 추상메소드 형태로 선언해 놓고
각 Controller에 지정하여 구현하도록 한다.
- 메소드 내부에서의 DB연산 작업들은 모두 DAO로 분리하여 사용한다.
- 내부 작업이 모두 완료되면 페이지를 이동할 것인지, 어떤 방식으로 할 것인지, 그리고 어디로
이동할 것인지를 결정해서 리턴해야 한다. 
- 이에 관련된 필드를 클래스로 만들어 놓은 후
Controller안에 선언한 메소드의 리턴타입으로 지정하여 Front-Controller에 리턴해준다.
- Front-Controller에서는 해당 Controller 메소드의 리턴 값에 담긴 결과에 맞게 처리한 후
View로 이동하게 된다.

* * *

## Redirect와 Forward
### redirect(request객체 초기화)
- 클라이언트가 요청했을 때 이전의 값이 남아있지 않도록 하기 위해 사용한다.
- 회원가입, 글 작성, 결제 등

### forward(request객체 유지)
- 클라이언트가 request객체를 통해 응답페이지로 값을 전달해야 할 경우 혹은
단순 조회를 요청할 경우 사용된다.
- 목록, 검색 등
